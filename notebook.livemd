# Advent of Code 2022

```elixir
Mix.install([
  {:memoize, "~> 1.4"},
  {:tesla, "~> 1.4"},
  {:hackney, "~> 1.18"}
])

defmodule Api do
  use Tesla
  use Memoize

  @session System.get_env("AOC_SESSION")

  adapter(Tesla.Adapter.Hackney)

  plug(Tesla.Middleware.BaseUrl, "https://adventofcode.com/2022/day/")
  plug(Tesla.Middleware.Headers, [{"cookie", "session=#{@session}"}])

  defmemo get_input(day) do
    {:ok, response} = get("#{day}/input")
    response.body
  end
end

:ok
```

## Task 1

```elixir
test_input = """
1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
"""

solve1 = fn input ->
  input
  |> String.split("\n\n")
  |> Enum.map(fn cals ->
    cals |> String.split("\n", trim: true) |> Enum.map(&String.to_integer/1) |> Enum.sum()
  end)
  |> Enum.max()
end

24000 = solve1.(test_input)
solve1.(Api.get_input(1)) |> IO.inspect(label: "1.1")

solve2 = fn input ->
  input
  |> String.split("\n\n")
  |> Enum.map(fn cals ->
    cals |> String.split("\n", trim: true) |> Enum.map(&String.to_integer/1) |> Enum.sum()
  end)
  |> Enum.sort(&>=/2)
  |> Enum.take(3)
  |> Enum.sum()
end

45000 = solve2.(test_input)
solve2.(Api.get_input(1)) |> IO.inspect(label: "1.2")

:ok
```

## Task 2

```elixir
test_input = """
A Y
B X
C Z
"""

solve1 = fn input ->
  input
  |> String.split("\n", trim: true)
  |> Enum.map(fn round ->
    String.split(round, " ")
    |> case do
      ["A", "X"] -> 1 + 3
      ["A", "Y"] -> 2 + 6
      ["A", "Z"] -> 3 + 0
      ["B", "X"] -> 1 + 0
      ["B", "Y"] -> 2 + 3
      ["B", "Z"] -> 3 + 6
      ["C", "X"] -> 1 + 6
      ["C", "Y"] -> 2 + 0
      ["C", "Z"] -> 3 + 3
    end
  end)
  |> Enum.sum()
end

15 = solve1.(test_input)
solve1.(Api.get_input(2)) |> IO.inspect(label: "2.1")

solve2 = fn input ->
  input
  |> String.split("\n", trim: true)
  |> Enum.map(fn round ->
    String.split(round, " ")
    |> case do
      ["A", "X"] -> 3 + 0
      ["A", "Y"] -> 1 + 3
      ["A", "Z"] -> 2 + 6
      ["B", "X"] -> 1 + 0
      ["B", "Y"] -> 2 + 3
      ["B", "Z"] -> 3 + 6
      ["C", "X"] -> 2 + 0
      ["C", "Y"] -> 3 + 3
      ["C", "Z"] -> 1 + 6
    end
  end)
  |> Enum.sum()
end

12 = solve2.(test_input)
solve2.(Api.get_input(2)) |> IO.inspect(label: "2.2")

:ok
```

## Task 3

```elixir
test_input = """
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
"""

priorities =
  [?a..?z, ?A..?Z]
  |> Enum.flat_map(fn chars -> Enum.map(chars, &<<&1::utf8>>) end)
  |> Enum.with_index(1)
  |> Enum.into(%{})

solve1 = fn input ->
  input
  |> String.split("\n", trim: true)
  |> Enum.map(fn rucksack ->
    with [first_half, second_half] <-
           rucksack
           |> String.split_at(div(String.length(rucksack), 2))
           |> Tuple.to_list()
           |> Enum.map(&(&1 |> String.split("", trim: true) |> MapSet.new())),
         [common] <- MapSet.intersection(first_half, second_half) |> MapSet.to_list() do
      Map.get(priorities, common)
    end
  end)
  |> Enum.sum()
end

157 = solve1.(test_input)
solve1.(Api.get_input(3)) |> IO.inspect(label: "3.1")

solve2 = fn input ->
  input
  |> String.split("\n", trim: true)
  |> Enum.chunk_every(3)
  |> Enum.map(fn rucksacks ->
    with [first, second, third] <-
           Enum.map(rucksacks, &(&1 |> String.split("", trim: true) |> MapSet.new())),
         [common] <-
           first |> MapSet.intersection(second) |> MapSet.intersection(third) |> MapSet.to_list() do
      Map.get(priorities, common)
    end
  end)
  |> Enum.sum()
end

70 = solve2.(test_input)
solve2.(Api.get_input(3)) |> IO.inspect(label: "3.2")

:ok
```

## Task 4

```elixir
test_input = """
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
"""

solve1 = fn input ->
  input
  |> String.split("\n", trim: true)
  |> Enum.map(fn pair_assignments ->
    pair_assignments
    |> String.split(",")
    |> Enum.map(fn elf ->
      elf
      |> String.split("-")
      |> Enum.map(&String.to_integer/1)
      |> then(fn [first, last] -> Range.new(first, last) |> Enum.to_list() |> MapSet.new() end)
    end)
    |> then(fn [first_elf_assignments, second_elf_assignments] ->
      MapSet.subset?(first_elf_assignments, second_elf_assignments) or
        MapSet.subset?(second_elf_assignments, first_elf_assignments)
    end)
  end)
  |> Enum.count(& &1)
end

2 = solve1.(test_input)
solve1.(Api.get_input(4)) |> IO.inspect(label: "4.1")

solve2 = fn input ->
  input
  |> String.split("\n", trim: true)
  |> Enum.map(fn pair_assignments ->
    pair_assignments
    |> String.split(",")
    |> Enum.map(fn elf ->
      elf
      |> String.split("-")
      |> Enum.map(&String.to_integer/1)
      |> then(fn [first, last] -> Range.new(first, last) end)
    end)
    |> then(fn [first_elf_assignments, second_elf_assignments] ->
      Range.disjoint?(first_elf_assignments, second_elf_assignments)
    end)
  end)
  |> Enum.count(&(!&1))
end

4 = solve2.(test_input)
solve2.(Api.get_input(4)) |> IO.inspect(label: "4.2")

:ok
```
